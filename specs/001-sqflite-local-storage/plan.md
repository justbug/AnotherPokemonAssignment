# Implementation Plan: SQLite Local Favorites Persistence

**Branch**: `001-sqflite-local-storage` | **Date**: 2025-10-20 | **Spec**: [spec.md](./spec.md)  
**Input**: Feature specification from `/specs/001-sqflite-local-storage/spec.md`

## Summary

Replace the Flutter `LocalPokemonService` backing store with a SQLite
implementation that preserves the `LocalPokemonServiceSpec` contract and keeps
feature parity with the Swift client. The plan delivers resilient CRUD
operations, diagnostics telemetry, and automated coverage for both success and
failure paths.

## Technical Context

**Language/Version**: Dart 3.9 (Flutter 3.x), Swift 5.9 (parity verification)  
**Primary Dependencies**: `sqflite` for local DB, `path`/`path_provider` for file
resolution, existing `flutter_bloc`, `freezed`, `json_serializable`, Swift
UserDefaults store (baseline)  
**Storage**: SQLite file stored per device (fresh store); Swift client retains
UserDefaults but must remain behaviorally aligned  
**Testing**: `flutter test` with bloc/repository specs, `mockito`-based service
tests, integration smoke on physical/emulated devices; `xcodebuild test` to
confirm iOS favorites remain intact  
**Target Platform**: Mobile (Flutter Android/iOS), iOS native app (verification)
**Project Type**: Dual mobile clients sharing backend contract  
**Performance Goals**: CRUD operations complete ≤3s on mid-tier devices; favorites
queries remain <100ms average; zero perceived regression vs current behavior  
**Constraints**: Must execute offline; database schema versioned for forward/backward
compatibility; no data loss permitted  
**Scale/Scope**: Favorites capped by Pokédex (~1000 entries) per user; coordination
with Swift team required for parity validation

## Constitution Check

*GATE: Must pass before Phase 0 research.*

- **Cross-Platform Feature Parity (NON-NEGOTIABLE)**: Store changes cannot break or
  diverge favorites behavior across Flutter and Swift. Plan must include parity
  verification (shared fixtures, regression tests). ✅ Included as acceptance
  criteria and test tasks.
- **Typed API Contracts & Shared Domain Models**: `LocalPokemon` schema must stay
  consistent; serializers regenerated. ✅ Data model
  section will freeze schema and require regenerated `freezed`/JSON artifacts.
- **State Management Discipline**: No business logic leaks into widgets or view
  controllers. ✅ Work remains inside services/repositories with tests.
- **Test-Centric Delivery**: Automated tests required for services, error
  handling; both `flutter test` and `xcodebuild test` run before merge. ✅
  Captured in testing plan.
- **Resilient Favorites Persistence**: Ensure idempotent persistence, error
  surfacing, and retry; analytics/diagnostics required. ✅ Called out in
  requirements and plan deliverables.

## Project Structure

### Documentation (this feature)

```
specs/001-sqflite-local-storage/
├── plan.md
├── research.md
├── data-model.md
├── quickstart.md
├── contracts/
└── tasks.md            # generated by /speckit.tasks
```

### Source Code (repository root)

```
flutter_another_pokemon_assignment/
├── lib/
│   ├── models/local_pokemon.dart
│   ├── repositories/list_repository.dart
│   ├── services/
│   │   ├── local_pokemon_service.dart
│   │   └── local_pokemon_service_spec.dart
│   └── blocs/...
├── test/
│   ├── services/local_pokemon_service_test.dart
│   ├── repositories/...
│   └── fixtures/...
└── pubspec.yaml

AnotherPokemonAssignment/
└── AnotherPokemonAssignment/
    ├── Favorite/
    │   ├── FavoritePokemonViewModel.swift
    │   └── Stores/UserDefaultsStore.swift
    └── Tests/
        └── FavoriteTests/
```

**Structure Decision**: Implement SQLite-backed service within
`flutter_another_pokemon_assignment/lib/services/` and mirror parity validation via
Swift tests under `AnotherPokemonAssignment/Tests`. No new top-level packages required.

## Complexity Tracking

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| _None_ | — | — |

## Phase 0 — Research Tasks
- Validate SQLite schema design, including column naming that matches
  `LocalPokemon` JSON keys, and document R/W helpers (see `research.md`).
- Investigate concurrency guarantees for sqflite and adopt synchronization plan.
- Decide on telemetry payload structure for persistence outcomes.

## Phase 1 — Design & Contracts Deliverables
- Produce `data-model.md` capturing `LocalPokemon` schema, keeping parity with Swift data expectations.
- Publish storage contract in `contracts/local_pokemon_storage_contract.md`
  outlining required operations, telemetry, and performance guarantees.
- Draft `quickstart.md` instructions covering dependency updates, persistence smoke tests,
  and parity validation steps.
- Update agent context (Codex) with new dependencies (`sqflite`, `path_provider`,
  `synchronized`) once design is ratified.

## Constitution Re-check (Post-Design)
- Confirm schema changes remain aligned with Swift model; engage Swift owners if
  new fields such as `updatedAt` require adoption.
- Ensure planned automated tests cover CRUD paths, error handling, and telemetry emission,
  satisfying Test-Centric Delivery.
- Validate parity gates by scheduling joint regression run (`flutter test`,
  `xcodebuild test`) before implementation tasks proceed.
